/* Base model all for all definitions */

/**
 * Binds all methods of a class instance to itself.
 */
export const autoBind = function (instance) {
  for (let obj = instance; obj; obj = Object.getPrototypeOf (obj)) {

    // We're the end of the inheritance chain if we've reached 'Object'.
    if (obj.constructor.name === 'Object') {
      return;
    }

    let names = Object.getOwnPropertyNames (obj);

    // Bind each function to the instance.
    for (let i = 0; i < names.length; i++) {
      let name = names[i];

      // No need to bind getters, as attempting to access them would also
      // invoke them which is something we don't want to do here.
      if (Object.getOwnPropertyDescriptor (obj, name).get) {
        continue;
      }

      // We're using `defineProperty` here so that we don't make all the
      // class methods enumerable when we replace them.
      if (typeof obj[name] === 'function' && name !== 'constructor') {
        Object.defineProperty (instance, name, {
          value: instance[name].bind (instance),
          enumerable: false,
          configurable: true,
          writable: true
        });
      }
    }
  }
}

/**
 * Reserved keywords that can't be used for attribute or option names.
 */
const RESERVED = [
    '_attributes',
    '_listeners',
    '_uid',
    'attributes',
    'busy'
];

/**
 * Base class for all things common between Model and Collection.
 */
export class Base {
  constructor(data, options) {
    autoBind(this)

    // Define an automatic unique ID. This is primarily to distinguish
    // between multiple instances of the same name and data.
    Object.defineProperty(this, '_uid', {
      value: 'idx_'+(new Date()).getTime(),
      enumerable: false,
      configurable: false,
      writable: false
    });

    this._listeners = {}; // Event listeners
    this._attributes = {}
    this._options = this.defaultOptions(); // Internal option store
    this.setOptions(options);

    this.setData(Object.assign(this.defaults(), data)); // Model attributes

    this._busy = false;
    this._changed = false;
    this._request = null;
    this.boot();
  }

  /**
   * If model process some network requests
   *
   * @return {boolean}
   */
  get busy () {
    return this._busy
  }

  /**
   * If model has changes but yet saved to server
   *
   * @return {boolean}
   */
  get changed () {
    return this._changed
  }

  /**
   * @returns {string} The class name of this instance.
   */
  get $class () {
    return (Object.getPrototypeOf(this)).constructor.name;
  }

  /**
   * Abort network request
   */
  abort () {
    this._busy = false
    this._request.reject()
  }

  /**
   * Called after construction, this hook allows you to add some extra setup
   * logic without having to override the constructor.
   */
  boot () {
  }

  /**
   * Property refs definitions
   * @return {object}
   */
  refs () {
    return {}
  }

  /**
   * Property paths
   * @return
   */
  types () {
    return {}
  }

  /**
   * Return true if idKey set in property and attributes contains
   * such key and value
   * @return {boolean}
   * @default false
   */
  get isNew () {
    let idKey = this.getOption('idKey')
    if (idKey === undefined) {
      return true
    }

    return !this._attributes[idKey]
  }

  /**
   * Returns the default context for all events emitted by this instance.
   *
   * @returns {Object}
   */
  getDefaultEventContext () {
    return {
      target: this
    }
  }

  has (name) {
    return (Object.keys(this._attributes).indexOf(name) !== -1)
  }

  /**
   * Similar to `saved`, returns an attribute's value or a fallback value
   * if this model doesn't have the attribute.
   *
   * @param {string} attribute
   * @param {*}      fallback
   *
   * @returns {*} The value of the attribute or `fallback` if not found.
   */
  get(attribute, fallback) {
      return this._attributes[attribute] || fallback;
  }

  /**
   * Registers an attribute on this model so that it can be accessed directly
   * on the model, passing through `get` and `set`.
   */
  registerAttribute(attribute) {
      // Protect against unwillingly using an attribute name that already
      // exists as an internal property or method name.
      if (RESERVED.indexOf(attribute) !== -1) {
          throw new Error(`Can't use reserved attribute name '${attribute}'`);
      }

      // Create dynamic accessors and mutations so that we can update the
      // model directly while also keeping the model attributes in sync.
      Object.defineProperty(this, attribute, {
          get: () => this.get(attribute),
          set: (value) => this.setProperty(attribute, value)
      })
  }

  /**
   * @returns {string} Default string representation.
   */
  toString () {
    return `<${this.$class} #${this._uid}>`
  }

  /**
   * @returns {Object} An empty representation of this model.
   *                   It's important that all model attributes have a default
   *                   value in order to be reactive in Vue.
   */
  defaults () {
    return {}
  }

  /**
   * Default model configuration
   */
  defaultOptions () {
    return {
      shouldPatch: false,
      fetchParsePath: 'data',
      saveParsePath: 'data',
      createParsePath: 'data'
    }
  }

  /**
   * Emits an event by name to all registered listeners on that event.

   * Listeners will be called in the order that they were added. If a listener
   * returns `false`, no other listeners will be called.
   *
   * @param {string} event    The name of the event to emit.
   * @param {Object} context  The context of the event, passed to listeners.
   */
  emit (event, context = {}) {
    let listeners = this._listeners[event];
    if (Array.isArray(listeners)) {
      // Create the context for the event.
      context = Object.assign({}, context, this.getDefaultEventContext());
      // Run through each listener. If any of them return false, stop the
      // iteration and mark that the event wasn't handled by all listeners.
      listeners.forEach(function (listener) { listener(context) })
    }
  }

  /**
   * Registers an event listener for a given event.
   *
   * Event names can be comma-separated to register multiple events.
   *
   * @param {string}   event      The name of the event to listen for.
   * @param {function} listener   The event listener, accepts context.
   */
  on (event, listener) {
    let current = this._listeners[event]
    if (Array.isArray(current)) {
      this._listeners[event].push(listener)
    } else {
      this._listeners[event] = [listener]
    }
  }

  /**
   * @param {Array|string} path     Option path resolved by `_.get`
   * @param {*}            fallback Fallback value if the option is not set.
   *
   * @returns {*} The value of the given option path.
   */
  getOption(path, fallback = null) {
    return this._options[path] || fallback;
  }

  /**
   * @returns {Object} This instance's default options.
   */
  options () {
    return {
      idKey: 'id'
    }
  }

  /**
   * Sets an option.
   *
   * @param {string} path
   * @param {*}      value
   */
  setOption (path, value) {
    this._options[path] = value
    return this
  }

  /**
   * Sets all given options. Successive values for the same option won't be
   * overwritten, so this follows the 'defaults' behaviour, and not 'merge'.
   *
   * @param {...Object} options One or more objects of options.
   */
  setOptions (options) {
    Object.assign(this._options, options)
    return this
  }

  /**
   * Returns all the options that are currently set on this instance.
   *
   * @return {Object}
   */
  getOptions () {
    return this._options || {}
  }

  /**
   * Fetches data from the database/API.
   *
   * @param {options}             Fetch options
   * @param {options.params}      Query params
   * @param {options.headers}     Query headers
   * @returns {Promise}
   */
  fetch (options) {
    let method = this.getOption('fetch', options['method'] || false)
    if (method === false) {
      return Promise.reject('No method specified for fetch method')
    }

    if (typeof method === 'function') {
      return method().then(this.parse)
    }
  }

  /**
   * Set wall attributes
   *
   * @param data {object}
   */
  setData (data) {
    let _this = this

    Object.keys(data).forEach(function (key) {
      _this.setProperty(key, data[key])
    })
  }

  /**
   * Change model property
   *
   * @param attribute
   * @param value
   */
  setProperty(attribute, value) {
    let refs = this.refs()
    let types = this.types()
    let defaults = this.defaults()

    let defined = this.has(attribute)
    if (defined === false && Object.keys(defaults).indexOf(attribute) !== -1) {
      this.registerAttribute(attribute)
    }

    let previous = this.get(attribute, undefined)
    let changed = false
    if (refs[attribute] && types[attribute] === 'array' && Array.isArray(value)) {
      changed = true
      value.forEach(function (item) {
        if (item instanceof refs[attribute]) {
          this._attributes.push(item)
        } else {
          this._attributes.push(new refs[attribute](item))
        }
      })
    } else if (refs[attribute] && types[attribute] === 'ref') {
      changed = true
      this._attributes[attribute] = new refs[attribute](value)
    } else {
      changed = true
      this._attributes[attribute] = value
    }

    if (defined && changed) {
      this.emit('change', {attribute, previous, value});
    }
  }

  /**
   * Parse response from web server
   *
   * @param response
   * @param method {string}
   */
  parse (response, method) {
    let path = this.getOption(method + 'ParsePath', 'data')
    let data = response[path]
    let _this = this
    Object.keys(this._attributes).forEach(function (key) {
      if (data[key] === undefined) return
      _this.setProperty(key, data[key])
    })
  }

  /**
   * Persists data to the database/API.
   * @returns {Promise}
   */
  save () {}

  /**
   * Removes model or collection data from the database/API.
   * @returns {Promise}
   */
  delete () {}
}
